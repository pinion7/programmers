function solution(n, m) {
  // 분석
  // 1. 최대공약수
  // n과 m 중 n이 더 작은 수라고 가정하고, m 나누기 n을 했을 때
  // 나누어 떨어지면 -> n이 최대공약수가 된다.
  // 나누어 떨어지지 않으면 -> 여기에서 나온 나머지 값으로 n을 다시 나눈다.
  // 이 과정을 반복하면 결국 나누어 떨어지게 되고, 그 시점의 나누기 시행 수가 최대공약수가 된다.
  // 2. 최소공배수
  // n * m을 앞서 구한 최대공약수로 나누면 최소공배수가 된다.
  
  // 풀이
  // 우선 최대공약수를 구하는 함수를 구현해주면 편하다.
  const maxDivisor = (a, b) => {
      // 지속적으로 나누기 연산을 해야하기 때문에 재귀를 적용해주자.
      // 우선 base case를 구현
      // 나누어 떨어졌을 때 연산을 시행한 약수가 최대공약수이다.
      if (b === 0) return a;
      
      // recursive case
      // 나누어 떨어지지 않았을 때는, 나머지로 더 작은 수를 나눈다.
      // 둘 중 더 작은 수를 나머지로 나누다보면 나머지가 0이 되는 순간이 온다.
      // 즉, 결국 나누어 떨어졌을 때, 나누기를 시행한 해당 수를 리턴해주면 된다. 
      if (a > b) return maxDivisor(b, a % b);
      else return maxDivisor(a, b % a);
  }

  // 결과 변수를 만들어 주고
  const result = [];
  
  // 최대공약수부터 구해서 넣어 주고, 그걸 활용해 최소공배수도 넣는다.
  result.push(maxDivisor(n, m));
  result.push(n * m / result[0]);
 
  // 결과를 리턴한다.
  return result;
}