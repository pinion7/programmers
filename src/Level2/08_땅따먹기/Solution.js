function solution(land) {
  // 분석
  // land는 2차원 배열로 구성되어 있다. 행은 배열, 열은 number타입이다.
  // 행렬이 가진 각 타입의 특징을 잘 핸들링하여 동적계획법으로 풀어야한다.
  // 모든 라인별 가질 수 있는 최대값을 동적으로 저장해간다.
  // 첫 행은 변화가 없겠지만, 두 번째 행부터는 각 요소값이 누적시켜 한다.
  // 현재 행의 모든 열마다 이전 행의 최대값을 누적하되, 
  // 주의해야할 점은 '같은 열을 제외한 것 중 최대값'을 누적해야한다는 부분이다.
  // 그렇게 쌓아가게 되면 모든 라인에 대한 dp과정이 종료됐을 시
  // 마지막 행에 각 열에 가능한 최선의 값이 쌓일 것이고, 
  // 그 중 최대값이 곧 문제에서 원하는 결과값이라고 할 수 있다.

  // 풀이
  // 1. 동적계획법의 포인트를 잘 살릴 수 있도록 reduce를 사용해 보겠다.
  // 매 순회마다 acc에 값이 누적된 행을 반환해 줘야 한다.
  // 행에 값을 누적하기 위해 행의 인덱스도 인자로 넘겨서 활용해준다.
  const result = land.reduce((acc, curr, rowIdx) => {
     
     // 2. 첫 행의 경우 누적될 값이 없으므로 그대로 리턴한다.
     if (rowIdx === 0) return acc;
     
     // 3. 두 번째 행부터는 누적이 진행되어야 한다.
     // 이전 행(acc)의 요소에서 같은 열(동일 인덱스)을 제외하고,
     // 남은 요소 중 최대값을 구하여 현재 요소값에 합산해준다.
     else return curr.map((el, colIdx) => {
         const prev = acc.slice();
         prev.splice(colIdx, 1);
         return el + Math.max(...prev);
     });
  })
  
  // 4. result는 모든 요소에 가능한 최대값이 누적되어서 반환된 배열이다.
  // 이를 스프레드로 풀어서 최대값을 리턴해주면 된다.
  return Math.max(...result);
}