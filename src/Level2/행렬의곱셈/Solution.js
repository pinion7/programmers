function solution(arr1, arr2) {
  // 분석
  // 행렬의 곱셉법에 대해 알아야한다.
  // arr1의 첫번째 행과 arr2의 첫번째 열값들만 곱해서 합산한 값이
  // 새로운 배열의 [0][0]의 값이 된다. [0][1]의 값은 
  // arr1 첫번째 행과 arr2의 두번째 열값들만 곱해서 합산한 값이다.
  // 이런 식으로 쭉 연산한 결과 배열을 반환해주면된다.
  // 기본적으로 반복문을 3개를 중첩시키면 어렵지 않게 풀릴 수 있는 문제이다.
  // 1) arr1의 행과, result의 행을 순회할 반복문
  // 2) arr1의 열과, arr2의 행을 순회할 반복문
  // 3) arr2의 열과, result의 열을 순회할 반복문 까지 총 3개인 셈이다.
  
  // 풀이 - 배열 메소드를 활용
  // 배열 메소드에 대한 이해가 부족하면 시도하기 어려운 방식일 수 있다.
  // 1. arr1의 행길이가 결과배열의 행길이와 같으므로 먼저 map을 실행한다.
  // 2. 두 번째로는 arr2의 요소에도 map을 주어 접근해준다.
  // arr2의 열길이가 결과배열의 열길이와 같을 것이기 때문이다.
  // 3. map안에서 reduce를 반복하여 2차원배열에 값을 누적해가면 된다.
  // arr1를 reduce의 기준으로 삼고, arr2는 인덱스로 접근을 하면 된다.
  // 4. 반환흐름: 리듀스에서 산출된 값은 두번째 맵에서 배열의 형태로 갖춰지고,
  // 그 결과는 또 다시 첫번째 맵을 통해 배열 안에 배열의 형태로 누적이 된다.
  const result = arr1.map((_, rIdx, org) => {
      return arr2[0].map((_, cIdx) => {
          return org[rIdx].reduce((acc, curr, curIdx) => {
              return acc += curr * arr2[curIdx][cIdx];
          }, 0);
      });
  });
  
  return result;
};