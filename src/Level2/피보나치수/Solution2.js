function solution(n) {    
  // 풀이 2 - 재귀적인 풀이
  // 1. 원리는 풀이 1과 거의 같다. 동적계획법이다.
  // 2. 마찬가지로 0, 1을 배열에 미리 초기값으로 두고 사용한다.
  // 3. 재귀함수를 구현하고 내부를 탈출조건과 재귀조건으로 나눈다.
  // 4. 저장된 값이면 그대로 리턴, 
	// 5. 저장된 값이 아니면 연산(1234567 나누기 연산 포함)하여 저장 후 리턴한다.

  const temp = [0, 1];
  const fibonacci = (n) => {
      if (temp[n] !== undefined) return temp[n];
      temp[n] = (fibonacci(n - 1) + fibonacci(n - 2)) % 1234567;
      return temp[n];
  }
  
  return fibonacci(n);
}

	// ※ 해당 문제 테스트 케이스 13~14번의 경우, 입력값이 10만 단위이다.
	// 이 경우, 자바스크립트 콜스택 한계 수치를 넘어가서 런타임 오류가 난다.
	// 즉, 이 문제에 한해서는 자바스크립트 재귀방식으로 테스트케이스를 전부 통과할 수 없다.
	// 단, 풀이 자체에는 문제가 없으며, 피보나치를 해결하는 가장 명확한 재귀풀이법이다.