function solution(n) {
  // 분석
  // 피보나치의 경우 일반적인 연산으로는 시간복잡도가 엉망이 되기 쉽다.
  // 값을 저장해두고 이미 존재하는 값은 다시 재활용할 수 있어야 한다.
	// 그리고 재활용한 값을 바탕으로 다음 값을 만들어가는 동적계획법을 실행해야 한다.
  // for문으로 해결할거라면 tabulation 방식을 사용하고
  // 재귀적으로 접근할 거라면 memoization 방식을 써줘야 한다.
  // 2가지로 모두 풀어보겠다.
  
  // 풀이 1 - for문 풀이
  // 1. 배열에 0, 1번째 값만 저장하고 시작한다.
  // 2. for문의 시작 인덱스를 2부터하여 값을 n까지 누적한다.
  // 3. 연산 중 항상 1234567으로 나눠줘야 한다. (그래야 값오류방지 가능)
  // 4. 항상 저장된 값이 활용되기 때문에 두번 연산을 하지 않는다.
  // 5. 반복문이 끝나고 temp의 n번째 요소를 반환하면 된다.

  const temp = [0, 1];
  for (let i = 2; i <= n; ++i) {
      temp[i] = (temp[i - 2] + temp [i - 1]) % 1234567;;
  }

  return temp[n];
}