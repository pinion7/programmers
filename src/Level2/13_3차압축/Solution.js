function solution(msg) {
  // 분석
  // 주어진 LWZ 압축 조건에 맞게 코드를 구현하면 된다.
  // 우선 입력된 문자로 만들 수 있는 가장 긴 길이의 문자열을
  // 차례로 사전에 있는지 체크하는 과정이 선행되어야 한다.
  // 체크되는 게 있는 순간 해당 문자열의 색인번호를 뽑아두고
  // 다음 글자와 합쳐서 사전에 등록해준 뒤 제거한다.
  // 그리고 제거된 상태의 남은 문자열을 대상으로 위 과정을 반복한다.
  
  // 풀이
  // 1. 우선 사전을 만들어야 한다. A~Z까지 1에서 26번의 번호로 만든다.
  // 배열도 가능하지만 객체 형태가 추후 작업하기 좋을 것이다.
  // 아스키코드 65~90이 대문자 알파벳의 번호이다. 활용하면 좋다.
  const dic = {};
  for (let i = 65; i <= 90; ++i) {
      dic[String.fromCharCode(i)] = i - 64;
  }
  
  // 2. 출력값을 담을 배열을 만들고, 사전의 다음 인덱스도 선언한다.
  const result = [];
  let idx = 27;
  
  // 3. 현재 msg로 만들 수 있는 가장 긴 문자열을 탐색한다.
  // 가장 작은 단위부터 체크해가면서, 정의되어 있는 문자면 곧장 다음을 탐색하고
  // 정의되어 있지 않은 순간, 바로 이전 문자열까지가 정의된 문자열일 것이므로
  // 결과배열에 색인번호 푸쉬, 현재문자와 다음 문자열을 합친 결합문자도 사전에 등록,
  // 사전에 새로운 색인이 등록된 만큼 인덱스번호도 ++해준다.
  // 체크완료된 현재문자는 잘라서 제거하고, i도 조정하여 다시 처음부터 for문을 돌린다.
  for (let i = 1; i <= msg.length; ++i) {
      if (dic[msg.slice(0, i)] === undefined) {
          let currStr = msg.slice(0, --i);
          result.push(dic[currStr]);
          dic[currStr + msg[i]] = idx++;
          msg = msg.slice(i);
          i = 0;
      }
  }
  
  // 4. result에 곧장 마지막 남은 입력 문자인 msg를 넣고 결과를 반환한다.
  // *for문에서 탈출했다는 건, msg는 그자체로 사전에 등록된 문자인 셈이다.
  return result.concat(dic[msg]);
}