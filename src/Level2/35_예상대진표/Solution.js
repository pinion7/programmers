function solution(N, A, B) {
  // 분석
  // 생각보다 단순한 문제이다.
  // A, B를 2로 나누고 올림한 값을 계속 다시 A,B에 넣어주는 식으로 잘라나가면
  // 결국 1,2라는 값이 나올 수밖에 없음. 반복문으로 루프를 돌려주는데
  // 만약 두 값이 가까이 있다면 곧장 대결을 펼칠 수 있어 반복문을 이르게 탈출할 것이며
  // 멀리 있다면 그만큼 오랜 라운드 후에 만날 수 있기 때문에
  // 카운트 변수를 만들어서 이를 카운팅하면 라운드를 알 수 있을 것이다.

  // 풀이
  // 우선 둘 중 더 작은 수와 큰 수를 명확히 해주고 시작하자
  if (A > B) {
    let dummy = B;
    B = A;
    A = dummy;
  }

  // count를 처음엔 1을 주고 들어가자마자 탈출한다면
  // (N이 2라면) 1이 바로 리턴될 수 있게 한다.
  // N이 2라는 건 A, B가 1,2라는 것이고 1라운드만에 붙을 수 있기 때문이다.
  let count = 1;
  while (true) {
    // 서로의 차가 1이라는건 A가 1, B가 2가 됐다는 얘기.
    // 대결이 시작되는 순간이다.
    // 동시에 A(작은수)가 홀수여야만 두개의 차이가 1인게 의미가 있다.
    // A(작은수)가 짝수면 B가 바로 옆에 붙어 있어도 홀수이기 때문에
    // 대결을 곧장할 수 없기 때문이다.
    if (B - A === 1 && A % 2 === 1) break;
    // 짝수, 홀수 일때는 두 값이 바로 대결을 하면 안되는데,
    // 올림 처리를 해주면 서로 구분이 가능하다.
    // 반면 홀수, 짝수이면서 연속되는 수의 경우엔, 올림처리해도 값이 같아지는데,
    // 이미 반복문의 윗단에서 A가 홀수일 경우
    // 곧장 브레이크를 해주기 때문에 탈출해서 대결을 할 수 있다.
    A = Math.ceil(A / 2);
    B = Math.ceil(B / 2);
    ++count;
  }
  // 결과적으로 N을 전혀 사용하지도 않고 풀린 문제이다.
  return count;
}
